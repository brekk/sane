import { apL } from "Applicative"
import { mapLeft } from "Either"
import IO from "IO"
import List from "List"
import P from "Parse"
import String from "String"



export type Attribute = Attribute(String, String)
export alias Attributes = List Attribute

// <tag keyAttribute="keyValue">body</tag>
/**
 * XMLTags are composed of:
 * - tag - String
 * - attributes - List Attribute
 * - body - String
 */
export type XmlTag
  = Declaration(Attributes)
  | EmptyTag(String, Attributes)
  // | XmlTag(String, Attributes)
  | TextTag(String)
  | ParentTag(XmlTag, List XmlTag)
  | XmlComment(String)

export alias XML = List XmlTag

escapedChar :: P.Parser String
export escapedChar = do {
  backslash <- P.char('\\')
  escaped <- P.anyChar
  return pipe(
    String.fromList,
    of,
  )([backslash, escaped])
}


attribute :: P.Parser Attribute
export attribute = do {
  key <- pipe(
    P.manyTill(P.anyChar),
    map(
      pipe(
        String.fromList,
        String.trim,
      ),
    ),
  )(P.lookAhead(P.string(`="`)))
  _ <- P.char('=')
  _ <- P.char('"')
  value <- pipe(
    map(String.singleton),
    alt($, escapedChar),
    P.many,
    map(List.reduce(mappend, "")),
  )(P.notOneOf(['"', '\\']))
  _ <- P.char('"')

  return pipe(
    Attribute(key),
    of,
  )(value)
}

declaration :: P.Parser XmlTag
export declaration = do {
  _ <- P.string("<?xml")
  attrs <- P.some(P.token(attribute))
  _ <- P.token(P.string("?>"))
  return pipe(
    Declaration,
    of,
  )(attrs)
}

comment :: P.Parser XmlTag
export comment = do {
  _ <- P.string("<!--")
  chars <- pipe(
    P.someTill($, P.lookAhead(P.string("-->"))),
  )(P.anyChar)
  _ <- P.token(P.string("-->"))
  return pipe(
    String.fromList,
    String.trim,
    XmlComment,
    of,
  )(chars)
}

emptyElementTag :: P.Parser XmlTag
export emptyElementTag = do {
  _ <- P.char('<')
  tagStart <- pipe(
    P.manyTill(P.anyChar),
    map(String.fromList),
  )(P.oneOf(['/', ' ']))
  attrs <- P.manyTill(P.token(attribute), P.string("/>")) <|> pure([])
  _ <- P.token(P.string("/>"))
  return pipe(
    EmptyTag($, attrs),
    of,
  )(tagStart)
}

// emptyElementTagNoAttributes :: P.Parser XmlTag
// export emptyElementTagNoAttributes = do {
//   _ <- P.char('<')
//   tagStart <- pipe(
//     P.someTill(P.anyChar),
//     map(
//       pipe(
//         String.fromList,
//         String.trim,
//       ),
//     ),
//   )(P.char('/'))
//   _ <- P.token(P.string("/>"))
//   return pipe(
//     EmptyTag($, []),
//     of,
//   )(tagStart)
// }
//
// export emptyElementTag = P.choice([emptyElementTagWithAttributes, emptyElementTagNoAttributes])
/*
element :: P.Parser XmlTag
export element = do {
  _ <- P.char('<')
  tagStart <- pipe(
    P.someTill(P.anyChar),
    map(String.fromList),
  )(P.lookAhead(P.oneOf([' ', '>'])))
  attrs <- P.manyTill(P.token(attribute), P.lookAhead(P.string(">")))
  _ <- P.token(P.string(">"))
  body <- P.manyTill(
    P.choice([
      element,
      pipe(
        P.many(P.anyChar),
        TextTag,
      ),
    ]),
    P.string("</" ++ tagStart ++ ">"),
  )
  return pipe(
    ParentTag($, attrs, body),
    of,
  )(tagStart)
}
*/
